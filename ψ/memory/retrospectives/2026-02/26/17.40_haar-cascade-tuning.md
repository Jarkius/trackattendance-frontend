# Session Retrospective — Haar Cascade Detection Tuning

**Session Date**: 2026-02-26
**Time**: ~16:00 - 17:40 GMT+7
**Duration**: ~100 min
**Focus**: Tune Haar cascade face detection for reliable kiosk greeting in .exe deployment
**Type**: Bug Fix / Tuning

## Session Summary

Continued from the .exe runtime fixes session. User deployed the rebuilt .exe with Haar cascade working (confirmed in logs), but detection was unreliable — too strict size filter, too low resolution, and occasional false positives. Iterative tuning session with real deployment logs driving each adjustment.

## Timeline

1. User shared .exe log confirming Haar cascade loads from `_MEIPASS` — both fixes from previous session verified working
2. Detection not triggering at `min_size_pct=0.40` even with face close to camera — value too strict
3. Lowered to 0.15, then user tried 0.08 — detection worked but slow (31s delay reported)
4. Diagnosed: 192x108 capture resolution too low for Haar cascade — face is only ~15-30px wide
5. Bumped resolution to 320x240, then to 640x480 for better angle tolerance
6. Detection still intermittent at laptop typing distance — lowered `minNeighbors` from 4 to 3
7. Added state transition logging (empty→present, present→empty, cooldown remaining, scan busy remaining)
8. Upgraded scan-busy and voice suppression logs from DEBUG to INFO for production visibility
9. False positive greetings reported (nobody present) — reverted `confirm_frames` from 2 back to 3
10. Updated `.env.example` throughout to match tuned defaults

## Files Modified

| File | Change |
|---|---|
| `plugins/camera/proximity_detector.py` | `minNeighbors` 4→3, state transition + cooldown logging |
| `plugins/camera/proximity_manager.py` | Scan-busy and voice suppression logs upgraded to INFO with remaining time |
| `.env.example` | Resolution 320→640x480, confirm_frames notes, overlay comment, min_size_pct 0.15 |
| `.env` | Resolution 640x480, min_size_pct 0.15, overlay comment |

## AI Diary

This session was a lesson in the gap between "works in theory" and "works at the kiosk." Every change I made was driven by real deployment logs — the user would paste the log, I'd read the values, diagnose, and suggest an adjustment. It was genuinely iterative in a way that code review alone can never be.

The biggest miss was the resolution. I'd originally set 192x108 thinking "proximity detection doesn't need high res" — true for MediaPipe which uses neural networks optimized for small inputs, but completely wrong for Haar cascade which needs actual pixel patterns to match against. A face at 15 pixels wide is just noise to a cascade classifier. Bumping to 640x480 was the right call, and I should have known that from the start. The detection chain (MediaPipe → Haar → motion) means different fallbacks have different resolution requirements, and I didn't account for that.

The `minNeighbors` knob is a classic precision-recall tradeoff. Dropping from 4 to 3 made detection more sensitive but introduced false positives from background patterns. The user reported occasional phantom greetings with nobody present. The fix was straightforward — increase `confirm_frames` back to 3 so a single false detection frame can't trigger a greeting. Three consecutive false positives in a row is rare enough to be acceptable.

The logging additions were overdue. Having state transitions, cooldown remaining, and scan-busy remaining in the production log would have saved significant back-and-forth in earlier sessions. I should add operational logging as part of the initial feature, not as an afterthought when debugging gets painful.

## Honest Feedback

**Friction 1: Resolution requirements differ per detection backend.** I optimized resolution for MediaPipe (which handles low-res well) but the .exe falls back to Haar cascade (which needs more pixels). When a feature has multiple backends, each backend's constraints must be considered independently. The "lowest common denominator" resolution should satisfy the weakest backend, not the strongest.

**Friction 2: Tuning knobs interact in non-obvious ways.** `min_size_pct`, `minNeighbors`, `confirm_frames`, `resolution`, and `cooldown` all interact. Lowering one (minNeighbors for sensitivity) requires compensating with another (confirm_frames for false positive filtering). A tuning guide or a "recommended profiles" section in `.env.example` would help operators find the right balance without trial-and-error.

**Friction 3: Operational logging should be first-class from day one.** State transitions, suppression reasons, and timing info were all at DEBUG level or missing entirely. The user couldn't see why greetings were or weren't firing without changing log levels. INFO-level operational logging for state machines is not optional — it's essential for production troubleshooting.

## Lessons Learned

- Haar cascade needs at least 640x480 resolution for reliable face detection at varied angles — 192x108 is insufficient
- When tuning detection sensitivity (minNeighbors), always compensate with temporal filtering (confirm_frames) to manage false positives
- State machine logging (transitions, suppression reasons, remaining timers) should be INFO level from the start

## Next Steps

- Rebuild .exe with latest code (minNeighbors=3, logging improvements)
- Test with `CAMERA_CONFIRM_FRAMES=3` and `CAMERA_RESOLUTION=640x480` at kiosk
- Monitor logs for false positive rate — if still too high, consider `confirm_frames=4`
- Consider adding `CAMERA_HAAR_MIN_NEIGHBORS` to .env if field tuning remains needed
